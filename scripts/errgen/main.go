package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"sort"
	"strings"

	"github.com/urfave/cli/v2"
	"gopkg.in/yaml.v3"
)

func main() {
	app := &cli.App{
		Name: "Error generator",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "out",
				Aliases: []string{"o"},
				Usage:   "path to generated .go `FILE`",
			},
			&cli.StringFlag{
				Name:    "package-name",
				Value:   "errors",
				Aliases: []string{"p"},
				Usage:   "set package `PACKAGE` in generated file",
			},
		},

		Usage:     "generate go code for declared errors",
		UsageText: "./errgen -o path-to-errors.go -p package-name  path-to-errors.yaml",
		Action: func(c *cli.Context) error {
			if c.NArg() < 1 {
				return errors.New("path to errors.yaml file required")
			}

			out := os.Stdout
			if goFileName := c.String("out"); goFileName != "" {
				f, err := os.Create(goFileName)
				if err != nil {
					return err
				}
				defer f.Close()
				out = f
			}

			return generate(c.Args().First(), out, c.String("package-name"))
		},
	}

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}

type errorsDecl struct {
	packageName string
	Errors      map[string][]struct {
		HttpCode int    `yaml:"http_code"`
		Code     string `yaml:"code"`
		Descr    string `yaml:"description"`
	}
}

func generate(yamlFileName string, result io.Writer, packageName string) error {
	yamlFile, err := os.Open(yamlFileName)
	if err != nil {
		return err
	}
	defer yamlFile.Close()

	var decl = errorsDecl{packageName: packageName}
	if err = yaml.NewDecoder(yamlFile).Decode(&decl); err != nil {
		return err
	}

	if err = makeGoErrors(&decl, result); err != nil {
		return err
	}

	return nil
}

func makeGoErrors(decl *errorsDecl, w io.Writer) error {
	buff := bytes.NewBuffer([]byte{})

	fmt.Fprintf(buff, "// Code generated by errgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(buff, "package %s\n\n", decl.packageName)

	groups := make([]string, 0, len(decl.Errors))
	for groupName := range decl.Errors {
		groups = append(groups, groupName)
	}

	sort.Strings(groups)

	for _, groupName := range groups {
		errs := decl.Errors[groupName]

		fmt.Fprintf(buff, "\n// %s \n\n", groupName)

		for _, err := range errs {
			codeParts := strings.Split(err.Code, ".")
			var errName string
			if len(codeParts) < 3 {
				errName = strings.Join(codeParts, "")
			} else {
				errName = strings.Join(codeParts[1:], "")
			}

			fmt.Fprintf(
				buff,
				"var Err%s = NewHttpError(%d, \"%s\", \"%s\")\n",
				errName,
				err.HttpCode,
				err.Code,
				err.Descr,
			)
		}
	}

	out, err := format.Source(buff.Bytes())
	if err != nil {
		return err
	}

	_, err = w.Write(out)
	return err
}
